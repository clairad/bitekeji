一、string、vector

1、string和vector的iterator是使用什么方式实现的？
2、string库中的append函数功能是什么？
3、string库中都有哪些查找函数？它们是如何进行查找的？
4、vector库中，reserve函数的功能是什么？如何实现这个功能的？
5、vector库中，insert函数和erase函数为什么会导致迭代器失效？
6、string和vector库中有个at函数，他的功能是什么？和[]重载有什么区别？



二、list

1、list的底层结构是什么？
2、list的迭代器都有哪些功能？他是怎么实现的？
3、list的迭代器失效是由哪个函数导致的？为什么会失效？



三、deque、stack、queue

1、简述deque的迭代器是怎么实现的。
2、简述stack和queue的功能。
3、stack和queue为什么选择deque作为自己的底层默认容器
4、简述priority_queue的功能。
5、什么是仿函数？它都有什么应用？
6、stack和queue除了使用deque外，还能使用哪些容器做自己的底层容器？



四、map、set、红黑树

1、简述map的中括号重载。
2、什么是AVL树？
3、什么是红黑树？
4、如何在红黑树中插入一个元素？
5、map的迭代器是如何实现++的。
6、如何从二叉搜索树中删除一个节点？


五、哈希

1、简述闭散列是如何处理哈希冲突的。
2、简述开散列的结构。
3、简述位图。
4、简述布隆过滤器。
5、如果构建的哈希表中，哈希冲突过多，那应该怎么优化？

1、线性探测：一旦发生冲突（该位置已经有元素了），那么就向后查找第一个没有被占用的位置，放上去。
2、链表数组，数组里每一个元素都是一个链表头，发生冲突，直接执行头插。每一组同义词结成一个链表。
3、位图是用位来处理的哈希表，也就是其中每一个位对应哈希表中的一个位置。由于只有一位，所以这个哈希表中的每一个值只能表示两种状态。
4、可以将一些不那么要求准确率的数据，每一条通过N个哈希函数处理，然后在一个位图里面，挑选对应的N位置1，查找的时候，再将待查找数据通过这N个哈希函数处理后，看看对应的位置上是不是都是1，如果有一个0，就代表这条数据一定不存在，如果全是1，就代表这个数据可能存在。
5、修改哈希函数



vector答案：
1、答出“原生指针”四个字即为对。
2、答出跟“+=”类似，即为对，答出有其他重载方式优秀
3、答出find、rfind及find是顺找，rfind是反找即为对，答出find_first_of和find_last_of优秀。
4、答出“扩容”、“重分配”即为对。
5、insert要答出“如果insert导致扩容才会失效”，erase要答出“erase本身不会导致失效，某些版本中会强制它失效”。
6、at函数功能相当于[]重载，不同的是，当越界的时候，at会抛出错误。


list答案：
1、带头循环双链表
2、类似指针，提供了解引用、箭头、++、--、==、!=等方法，由于是不连续空间，所以没有提供类似原生指针的+、-、>、<等方法。实现方式是封装了一个包含链表节点指针的类，然后重载对应运算符实现的。
3、erase，因为erase一定会导致当前的节点被释放掉。


deque答案：
1、有四个指针：1、所在元素的位置。2、所在缓冲区的头指针。3、所在缓冲区的尾指针。4、map中当前缓冲区所在位置的指针(二级指针)
重载了+ - > < []等完全模拟指针的迭代器。
2、答出“stack先入后出，queue是先入先出”就算对
3、因为deque是在双端进行插入和删除最快的容器。而stack和queue只有双端的插入删除需求。
4、答出“堆”就算对，答出“模拟实现了堆的功能，包括创建堆、插入、删除等功能”算优秀。
※什么是堆，要答出两点：父节点始终大于或小于两个孩子、这是用顺序表实现的完全二叉树。
5、重载了()运算符的类。
a、其对象可以在sort、count_if等函数中充当函数参数或在priority_queue、map等容器中充当传入的类型参数。
b、在类模板的实现中，经常会遇到一种情况，我需要一个方法，但是这个方法我不知道怎么实现，必须由用户定义，那么我就可以以一个仿函数(类型)的方式写在template列表里，用户就可以通过仿函数的方式传入，使我知道该怎么做。
c、是lambda表达式的底层实现。
6、stack只需要尾插尾删，所以vector和list都可以。queue需要尾插头删，vector不支持头删，所以只能是list。



map答案：
1、如果中括号内的key值不存在，则插入该key值，将对应的val的引用返回，以供赋值。
如果中括号内的key值存在，则直接返回对应val的引用。
2、一个特殊的二叉搜索树。它会记录每一个节点的平衡因子，当某个节点的平衡因子的绝对值超过1，则执行对应情况的旋转。
3、一个特殊的二叉搜索树。红节点不能相连，从根到叶子，每一条路径上的黑节点个数都是相同的。这样能保证每个节点的左右子树相对平衡（最极端的情况下，一个子树的高度是另一个子树的两倍）。
4、
5种情况：
a、我是根，直接插入。
b、父黑：直接插入。
c、父红叔红：叔父二人同改黑，爷爷改红，然后继续向上重复此过程。
d、父红叔黑，我跟爸爸一条线（左孩子）：右旋，父节点变成新的根，原来的爷爷节点变成新根的右孩子，同时变红。
e、父红叔黑，我跟爸爸扭一扭（爸爸是爷爷的左孩子，我是爸爸的右孩子）：先左旋，变成情况d，之后按情况d处理。
5、找它的后继结点：如果该节点有右子树，则找到右子树中最左端的节点就是后继结点；如果没有右子树，看自己是不是爸爸的左孩子，如果是，则爸爸是自己的后继节点；如果不是，继续向上遍历，直到某个节点是其爸爸的左孩子，则该节点是后继节点；如果找到根都没能找到，那么自己就是最后一个节点，下一个是end()。
6、先看我是不是叶子，如果是，那么直接删除，再看我是不是只有一个孩子，如果只有一个孩子，那么直接让我的孩子替代我的位置（我是爸爸的左子树，我就让我的孩子成为爸爸的左子树，右边亦然）。如果有两个孩子，就要找我的前驱或者后继节点，让它替代我的位置（由于该节点只有一个孩子，删除的时候使用上一种情况）。